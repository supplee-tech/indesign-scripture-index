#!/usr/bin/env python3
# pylint: disable=invalid-name

# import os.path
import re
import os
import sys
import csv
from copy import deepcopy
from dataclasses import dataclass, field

from jinja2 import Environment, FileSystemLoader
import fire

# from fodt_template import indic2arabic, log_debug
from fodt_template.languages import ArabicScript
# from fodt_template.meta import DocumentMeta
# from fodt_template.nodes import Index, IndexEntry, IndexHeading
# from fodt_template.templates import *
from fodt_template.verses import proper_books_names, VerseReference, VerseReferenceList


comma = 'ØŒ '


def first_char(text: str) -> str:
    return ArabicScript.strip_text(text)[0]


@dataclass
class Pages:
    page_numbers: list[int] = field(default_factory=list)

    def __str__(self) -> str:
        return self.compact()

    def append(self, page: int):
        self.page_numbers.append(page)

    def compact(self) -> str:
        i = 1
        last_page = None
        pages = list(set(deepcopy(self.page_numbers)))
        pages.sort()
        while i < len(pages):
            if not last_page and pages[i-1] == pages[i]-1 or (last_page and last_page == pages[i]-1):
                last_page = pages[i]
                del pages[i]

            else:
                if last_page:
                    pages[i-1] = f'{pages[i-1]}-{last_page}'
                    last_page = None

                pages[i-1] = str(pages[i-1])
                i += 1

        if last_page:
            pages[-1] = f'{pages[-1]}-{last_page}'
        else:
            pages[-1] = str(pages[-1])

        return comma.join(pages)


@dataclass
class ScriptureIndexEntry:
    ref: VerseReference
    pages: Pages | int
    entry: str = None
    item: str = None
    subitem: str = None
    modifier: str = None

    def __post_init__(self):
        if isinstance(self.pages, str):
            if self.pages == 'null':
                self.pages = 0
            else:
                # print(f'{self.pages} | {type(self.pages)}', file=sys.stderr)
                self.pages = int(self.pages)

        if isinstance(self.pages, int):
            pages = Pages()
            pages.append(self.pages)
            self.pages = pages

        if self.entry and '|' in self.entry:
            self.item, self.subitem = re.split(r'\s*\|\s*', self.entry)
        else:
            self.item = self.entry
            self.subitem = None

    def key(self) -> str:
        try:
            key = str(self.ref.book_num()).rjust(3, '0')
            if self.ref.chapter():
                key += ':' + self.ref.chapter().rjust(3, '0')

            if self.ref.verse():
                key += ':' + re.sub(r'^\d+', lambda m: m[0].rjust(3, '0'), self.ref.verse()) if self.ref.verse() else ''

            return key
        except TypeError:
            print(f'{str(self.ref.book_num())} : {self.ref.chapter()} : {self.ref.verse()} | {self.ref._set_ref_text} | {self.pages}', file=sys.stderr)
            return 'zzzzz'

    def entry_text(self) -> str:
        text = ''
        # print(f"{entry.key()} | {entry.ref.text_ar(mime_type='indesign')}\t{entry.pages}", file=f_output)
        if self.ref.chapter():
            text += f"{self.ref.chapter()}"
        if self.ref.chapter() and self.ref.verse():
            text += ":\u200f"
        if self.ref.verse():
            text += f"{self.ref.verse()}"

        return text

    def __str__(self) -> str:
        return f'Entry: {self.ref} | Item: {self.item} | Subitem: {self.subitem} | Modifier: {self.modifier} | Pages: {self.pages}'


@dataclass
class ScriptureIndexHeading:
    heading: str
    book_num: int
    entries: list[ScriptureIndexEntry] = field(default_factory=list[ScriptureIndexEntry])


def process_file(file_path: str, entries: list[ScriptureIndexEntry]):
    try:
        with open(file_path, 'r', newline='', encoding='utf-8') as csvfile:
            reader = csv.DictReader(csvfile)

            # Check if the required fields are present
            if 'entry' not in reader.fieldnames or 'page' not in reader.fieldnames:
                print(f"Error: File '{file_path}' does not contain 'entry' and 'page' columns.", file=sys.stderr)

            for row in reader:
                page = row['page'].strip()
                for vr in VerseReferenceList(text=row['entry'].strip()):
                    entries.append(ScriptureIndexEntry(ref=vr, pages=page, entry=row['entry']))

            return entries

    except FileNotFoundError:
        print(f"Error: File '{file_path}' not found.", file=sys.stderr)
    except csv.Error as e:
        print(f"Error reading CSV file '{file_path}': {e}", file=sys.stderr)

    return entries


def cmd(
    *csv_files: list[str],
    verbose: bool = False,
    output: str = None
):
    if output:
        f_output = open(output, mode='w', encoding='utf-8')
    else:
        f_output = sys.stdout

    entries: list[ScriptureIndexEntry] = []

    for csv_file in csv_files:
        entries = process_file(csv_file, entries=entries)

    entries.sort(key=lambda e: ArabicScript.strip_text(e.key()))

    # for entry in entries:
    #     print(entry.key(), '|', entry.entry, '|', entry.ref.text_ar(), file=f_output)

    i = 1
    while i < len(entries):
        if entries[i-1].key() == entries[i].key():
            for page in entries[i].pages.page_numbers:
                entries[i-1].pages.append(page)
            del entries[i]
        else:
            i += 1

    last_heading: ScriptureIndexHeading = None
    headings: list[ScriptureIndexHeading] = []

    for entry in entries:
        if not last_heading or entry.ref.book_num() != last_heading.book_num:
            last_heading = ScriptureIndexHeading(book_num=entry.ref.book_num(), heading=proper_books_names(entry.ref.book_num(), lang_code='ar'))
            headings.append(last_heading)
        last_heading.entries.append(entry)

    # Set up Jinja2 environment
    env = Environment(loader=FileSystemLoader('.'))
    template = env.get_template('templates/scripture-index.att')

    # Render the template
    f_output.write(template.render(headings=headings))


if __name__ == "__main__":
    fire.Fire(cmd)
